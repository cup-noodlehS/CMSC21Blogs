[
  {
    "title": "First Week of School!",
    "sub": "CMSC21 | Blog 1",
    "image": "/images/week1.jpg",
    "text": "<p>The first week of class was very chill, and we mainly had orientation sessions for all our courses. Our professors took the time to provide an overview of each course, outlining the objectives, learning outcomes, and grading systems, so that everyone had a clear understanding of what was expected of them. Also, some courses had a review of the lessons from last semester.</p><br><p>In addition, we were also introduced to the course syllabus and class schedule. The syllabus gave us students a detailed breakdown of the topics that would be covered throughout the semester.</p><br><p>Although the first week of the course was mainly an orientation, it was helpful for us to get a better understanding of what we would be learning throughout the semester. It also gave us an opportunity to meet our professors and block mates and get to know each other better. We had the chance to ask questions and get to know the expectations of the courses. We‚Äôre able to ask questions and clarify any concerns they may have had about the course materials.</p><br><p>In CMSC 21, we were given pretty challenging programming exercises. We enjoyed brainstorming with our block mates in order to solve the exercises. It also helped us review our programming knowledge from last semester.</p><br><p>Overall, our first week of classes was a great start to the semester, and we are excited to start learning more in the coming weeks and challenge ourselves as the week progress. We are eager to dive deeper into the material and challenge ourselves to learn as much as we can. We‚Äôre looking forward to the rest of the semester and seeing what each course has in store for us.</p>"
  },
  {
    "title": "2D arraysüíÄ",
    "sub": "CMSC21 | Blog 2: Arrays",
    "image": "/images/week2.jpg",
    "text": "<p>We can think of 2D arrays as grids. Like a grid, it has rows and columns, where we can store information inside it, and also manipulate it! We can also think of it like a matrix, where each element is accessed by its row and column index.</p><br><p>We think that as computer science students, we are likely to use 2D arrays frequently in our coding projects, especially those involving images, graphs, and matrices. Just like what we did in CMSC21 this week, where we used 2D arrays to make a tic-tac-toe game (which uses a 3x3 grid), and an object counter (which uses a grid, every element of the grid represents a pixel and uses 8-connected connectivity to determine the neighboring pixel which represents an object).</p><br><p>For us, the greatest use of 2D arrays is for storing and analyzing data in spreadsheets and databases because those are highly used in the tech industry. Since we are gamers, we also think that a great use for 2D arrays is for representing and manipulating images in computer graphics. As for 3D arrays, they can be used to represent 3D models in computer graphics. They are similar to 2D arrays, but with an added depth component. As for 4D arrays, we have no clue what‚Äôs the use of that, I guess it‚Äôs to complex :( But according to google, 4D arrays can be used for modeling higher-dimensional data or creating complex visualizations. huh :|</p><br><p>Now let‚Äôs talk about the machine problems that we talked about earlier (tic-tac-toe, and object counter). IT‚ÄôS HELLA HARD! Unlike all of our machine problems before, these ones are brain cells killers. For the tic-tac-toe, we need to check if no player has won (player wins if three ‚Äúx‚Äù or ‚Äúo‚Äù are in a straight line; could be diagonal), and if the board isn‚Äôt full, then if these conditions are true, we ask a player for the coordinates for their move, but if these conditions evaluate to false, then we stop asking for inputs then either print who is the winner or if the board is full. The logic isn‚Äôt quite complex but we probably struggled because we are not that knowledgeable in using 2D arrays in C. For the object counter, the logic is also not that complicated, but programming it and figuring out your approach to solve the problem was HARD.</p><br><p>Overall, we think that working with arrays is a fun and rewarding part of programming. The ability to manipulate data in a structured way opens up many possibilities for creative problem-solving and exploration. <p>"
  },
  {
    "title": "Pointers(‚òû Õ°¬∞ Õú ñ Õ°¬∞)‚òû",
    "sub": "CMSC21 | Blog 3: Pointers",
    "image": "/images/week3.jpg",
    "text": "<p>If I were to explain pointers to a five-year-old, I would make it sound like a fun adventure! So let's imagine that you're on a super-secret mission to find the most important toy in the world. To help you on your mission, you have a special notebook where you write down clues and notes about where the toy might be hidden.</p><br><p>But wait! Your notebook has a zillion pages and you don't have time to flip through them all. What can you do? That's where a pointer comes in! It's like a magic wand that helps you find the exact page where the clue you need is hidden. Just point your wand at the page and voila! You've found what you're looking for!</p><br><p>Now, imagine that you want to share a clue with your best friend, but you don't want to give away all your secrets. No worries! Your pointer is like a super-secret bookmark that only you and your friend can use. It helps you both find the exact page you need, without giving away everything in your notebook.</p><br><p>And guess what? This magical wand isn't just for finding clues in your notebook. It can also help you find things hidden deep in your computer's memory! So the next time you're on a top-secret mission, just remember to bring your trusty pointer with you. It's the ultimate tool for finding exactly what you need, without wasting any time!</p><br><p>To declare a pointer, you first specify the data type it will point to and use an asterisk symbol. For example, int *ptr; declares a pointer to an integer variable. You can assign the address of a specific variable to the pointer using the '&' symbol, like this: 'ptr = &myVariable;'.</p><br><p>To use a pointer, you dereference it using the asterisk symbol. For example, '*ptr' accesses the value that the pointer points to. You can manipulate the value of a variable using a pointer directly, such as *ptr = *ptr + 1; to increment the value of an integer variable.</p>"
  },
  {
    "title": "Memory Allocationüß†",
    "sub": "CMSC21 | Blog 4: Memory Allocation",
    "image": "/images/week4.jpg",
    "text": "<p>As someone with little to no experience in programming, I don't have much knowledge about memory allocation. However, with the help of Google, I found an example scenario related to my experience as a gamer - computer games. Dynamic memory allocation in computer games is commonly used for game objects and level data, as Google says. Game developers use dynamic memory allocation to allocate memory for every game object as it is created and then free that memory when it is no longer needed. This allows the game to allocate memory as needed, instead of reserving a fixed amount of memory for each possible game object. Similarly, dynamic memory allocation is used to allocate memory for level data as it is loaded and then freed after the level is finished.<br><br>It's like a giant Lego set (computer game) with many pieces, such as game objects and level data. As you build, you can add or remove pieces as needed.<br><br>Basically, dynamic memory allocation is a technique used in computer games to allocate memory as needed for game objects and level data, rather than reserving a fixed amount of memory for each possible object. This provides greater flexibility and efficiency in creating complex games and is similar to building a giant Lego set where you can add or remove pieces as needed.<br><br>Now, how can we use combinations of malloc, sizeof, and free? Malloc is used to dynamically allocate memory of a specified size, while sizeof is used to determine the size of a particular data type in bytes. Free is used to deallocate the memory allocated using malloc, which frees up the memory for further use.<br><br>For example, if we want to dynamically allocate memory for an integer variable, we can use malloc to allocate the memory, like so:<br><br>int *numPtr;<br>numPtr = (int*) malloc(sizeof(int));<br><br>This code dynamically allocates memory for an integer variable, and the sizeof(int) function is used to determine the size of an integer in bytes. Once the memory is no longer needed, we can use the free function to deallocate the memory:<br><br>free(numPtr);</p>"
  },
  {
    "title": "Li‚´ò‚´ò‚´ò‚´òsts",
    "sub": "CMSC21 | Blog 5: Lists",
    "image": "/images/week5.jpg",
    "text": "<p>Ah, lists! The bread and butter of any programmer's toolkit. Personally, I love lists. They're versatile, flexible, and easy to work with. I mean, what's not to love?<br><br>Now, when it comes to choosing between lists and arrays, it really depends on what you're trying to accomplish. If you need a fixed-size data structure, arrays are the way to go. But if you need something that can grow and shrink dynamically, lists are the way to go. Plus, lists offer a ton of built-in functionality that arrays don't, like sorting, reversing, and searching.<br><br>As for vectors and linked lists, I have to admit, I'm a bit biased towards linked lists. Sure, vectors are great for when you need constant-time access to elements, but there's just something so elegant about linked lists. Maybe it's the way they're built from a series of nodes, each pointing to the next one, creating a beautiful chain of data. Or maybe it's just that they're so darn good at handling insertions and deletions.<br><br>But let's not forget about the cleverness of lists. They're not just a simple data structure ‚Äì they're a work of art. I mean, think about it: a list is just a collection of elements, each with its own unique identity, yet somehow they all come together to form a cohesive whole. It's kind of like a team, really. Each member has their own strengths and weaknesses, but together they can accomplish great things.</p>"
  },
  {
    "title": "Persistence",
    "sub": "CMSC21 | Blog 6: Persistence",
    "image": "/images/week6.jpg",
    "text": "<p>As to what sir Eli discussed with us, persistence refers to a program's ability to store data even after it has finished running. This can be achieved by opening a file and saving the data to it using the appropriate file opening mode. One way to think of it is like a chef preparing ingredients in advance, carefully selecting and organizing them to ensure they can be retrieved later, and storing them to prevent spoilage.<br><br>There are several fopen modes available, each with a different purpose:</p><ul><li>'w': Write mode - opens a file for writing only. If the file doesn't exist, it will be created.</li><li>'r': Read mode - opens a file for reading only.</li><li>'a': Append mode - opens a file for writing at the end of the file. If the file doesn't exist, it will be created.</li><li>'w+': Write and read mode - opens a file for both writing and reading. If the file doesn't exist, it will be created.</li><li>'r+': Read and write mode - opens a file for both reading and writing.</li><li>'a+': Append and read mode - opens a file for both reading and writing at the end of the file. If the file doesn't exist, it will be created.</li></ul><p>By choosing the appropriate mode, the user can specify how the file will be accessed by the program. For example, the file can be opened for reading, writing, or both, depending on the user's needs.<br><br>I am finding the file manipulation part of the course to be particularly challenging. Unlike previous programming lessons, such as arrays and structs, file manipulation involves working with file pointers and file opening modes, which can be difficult to grasp. Additionally, this topic requires dealing with external resources that exist beyond the program's memory, making it essential to learn how to handle potential errors such as file opening failures and incorrect data formatting. Overall, I am finding this topic to be quite demanding, but I recognize that it is essential for developing robust programming skills.</p>"
  }
]
